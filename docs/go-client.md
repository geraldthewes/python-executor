# Go Client Library

The Go client provides a type-safe interface for executing Python code remotely.

## Installation

```bash
go get github.com/geraldthewes/python-executor/pkg/client
```

## Quick Start

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/geraldthewes/python-executor/pkg/client"
)

func main() {
    c := client.New("http://pyexec.cluster:9999/")

    // Create tar from a map of files
    tarData, _ := client.TarFromMap(map[string]string{
        "main.py": `print("Hello from Go!")`,
    })

    result, err := c.ExecuteSync(context.Background(), tarData, &client.Metadata{
        Entrypoint: "main.py",
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(result.Stdout)
}
```

## API Reference

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# client

```go
import "github.com/geraldthewes/python-executor/pkg/client"
```

Package client provides a Go client for the python\-executor service.

The python\-executor service allows remote execution of Python code in isolated Docker containers. This client handles all the complexity of the API, including tar archive creation, multipart requests, and response parsing.

### Quick Start

```
c := client.New("http://pyexec.cluster:9999/")

tarData, _ := client.TarFromMap(map[string]string{
    "main.py": `print("Hello from Go!")`,
})

result, err := c.ExecuteSync(context.Background(), tarData, &client.Metadata{
    Entrypoint: "main.py",
})
if err != nil {
    log.Fatal(err)
}

fmt.Println(result.Stdout)
```

### Creating Tar Archives

Several helper functions are provided for creating tar archives:

- TarFromMap: Create from a map of filename to content
- TarFromFiles: Create from a list of file paths
- TarFromDirectory: Create from a directory path
- TarFromReader: Create from an io.Reader \(e.g., stdin\)

<details><summary>Example (Async Execution)</summary>
<p>

Example\_asyncExecution demonstrates asynchronous execution. This example requires a running server.

```go
package main

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func getServerURL() string {
	if url := os.Getenv("PYEXEC_SERVER"); url != "" {
		return url
	}
	return "http://pyexec.cluster:9999/"
}

func main() {
	c := client.New(getServerURL())

	tarData, _ := client.TarFromMap(map[string]string{
		"main.py": `
import time
time.sleep(1)
print("Async complete!")
`,
	})

	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	// Submit asynchronously
	execID, err := c.ExecuteAsync(ctx, tarData, &client.Metadata{
		Entrypoint: "main.py",
	})
	if err != nil {
		fmt.Printf("Error submitting: %v\n", err)
		return
	}

	fmt.Printf("Submitted execution: %s\n", execID[:10]+"...")

	// Wait for completion
	result, err := c.WaitForCompletion(ctx, execID, 500*time.Millisecond)
	if err != nil {
		fmt.Printf("Error waiting: %v\n", err)
		return
	}

	fmt.Printf("Status: %s\n", result.Status)
	fmt.Printf("Output: %s", strings.TrimSpace(result.Stdout))
}
```

#### Output

```
Submitted execution: exe_550e84...
Status: completed
Output: Async complete!
```

</p>
</details>

<details><summary>Example (Execute Sync)</summary>
<p>

Example\_executeSync demonstrates synchronous execution. This example requires a running server.

```go
package main

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func getServerURL() string {
	if url := os.Getenv("PYEXEC_SERVER"); url != "" {
		return url
	}
	return "http://pyexec.cluster:9999/"
}

func main() {
	c := client.New(getServerURL())

	tarData, err := client.TarFromMap(map[string]string{
		"main.py": `print("Hello, World!")`,
	})
	if err != nil {
		fmt.Printf("Error creating tar: %v\n", err)
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := c.ExecuteSync(ctx, tarData, &client.Metadata{
		Entrypoint: "main.py",
	})
	if err != nil {
		fmt.Printf("Error executing: %v\n", err)
		return
	}

	fmt.Printf("Exit code: %d\n", result.ExitCode)
	fmt.Printf("Output: %s", strings.TrimSpace(result.Stdout))
}
```

#### Output

```
Exit code: 0
Output: Hello, World!
```

</p>
</details>

<details><summary>Example (Execute With Config)</summary>
<p>

Example\_executeWithConfig demonstrates execution with custom configuration. This example requires a running server.

```go
package main

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func getServerURL() string {
	if url := os.Getenv("PYEXEC_SERVER"); url != "" {
		return url
	}
	return "http://pyexec.cluster:9999/"
}

func main() {
	c := client.New(getServerURL())

	tarData, _ := client.TarFromMap(map[string]string{
		"main.py": `
import sys
print(f"Args: {sys.argv[1:]}")
print("Config test passed")
`,
	})

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := c.ExecuteSync(ctx, tarData, &client.Metadata{
		Entrypoint: "main.py",
		ScriptArgs: []string{"--verbose", "test.txt"},
		Config: &client.ExecutionConfig{
			TimeoutSeconds:  60,
			NetworkDisabled: true,
			MemoryMB:        512,
		},
	})
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Exit code: %d\n", result.ExitCode)
}
```

#### Output

```
Exit code: 0
```

</p>
</details>

<details><summary>Example (Multi File Execution)</summary>
<p>

Example\_multiFileExecution demonstrates executing multiple files. This example requires a running server.

```go
package main

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func getServerURL() string {
	if url := os.Getenv("PYEXEC_SERVER"); url != "" {
		return url
	}
	return "http://pyexec.cluster:9999/"
}

func main() {
	c := client.New(getServerURL())

	tarData, _ := client.TarFromMap(map[string]string{
		"main.py": `
from helper import calculate
result = calculate(5, 3)
print(f"Result: {result}")
`,
		"helper.py": `
def calculate(a, b):
    return a * b
`,
	})

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := c.ExecuteSync(ctx, tarData, &client.Metadata{
		Entrypoint: "main.py",
	})
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Output: %s", strings.TrimSpace(result.Stdout))
}
```

#### Output

```
Output: Result: 15
```

</p>
</details>

## Index

- [func DetectEntrypoint\(tarData \[\]byte\) \(string, error\)](<#DetectEntrypoint>)
- [func TarFromDirectory\(dirPath string\) \(\[\]byte, error\)](<#TarFromDirectory>)
- [func TarFromFiles\(files \[\]string\) \(\[\]byte, error\)](<#TarFromFiles>)
- [func TarFromMap\(files map\[string\]string\) \(\[\]byte, error\)](<#TarFromMap>)
- [func TarFromReader\(r io.Reader, filename string\) \(\[\]byte, error\)](<#TarFromReader>)
- [type AsyncResponse](<#AsyncResponse>)
- [type Client](<#Client>)
  - [func New\(baseURL string, opts ...Option\) \*Client](<#New>)
  - [func \(c \*Client\) ExecuteAsync\(ctx context.Context, tarData \[\]byte, metadata \*Metadata\) \(string, error\)](<#Client.ExecuteAsync>)
  - [func \(c \*Client\) ExecuteSync\(ctx context.Context, tarData \[\]byte, metadata \*Metadata\) \(\*ExecutionResult, error\)](<#Client.ExecuteSync>)
  - [func \(c \*Client\) GetExecution\(ctx context.Context, executionID string\) \(\*ExecutionResult, error\)](<#Client.GetExecution>)
  - [func \(c \*Client\) KillExecution\(ctx context.Context, executionID string\) error](<#Client.KillExecution>)
  - [func \(c \*Client\) WaitForCompletion\(ctx context.Context, executionID string, pollInterval time.Duration\) \(\*ExecutionResult, error\)](<#Client.WaitForCompletion>)
- [type CodeFile](<#CodeFile>)
- [type ExecutionConfig](<#ExecutionConfig>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ExecutionStatus](<#ExecutionStatus>)
- [type KillResponse](<#KillResponse>)
- [type Metadata](<#Metadata>)
- [type Option](<#Option>)
  - [func WithHTTPClient\(httpClient \*http.Client\) Option](<#WithHTTPClient>)
  - [func WithTimeout\(timeout time.Duration\) Option](<#WithTimeout>)
- [type SimpleExecRequest](<#SimpleExecRequest>)


<a name="DetectEntrypoint"></a>
## func DetectEntrypoint

```go
func DetectEntrypoint(tarData []byte) (string, error)
```

DetectEntrypoint finds the Python entrypoint in a tar archive.

The detection order is:

1. main.py \(highest priority\)
2. \_\_main\_\_.py
3. First .py file found

Returns an error if no Python files are found.

<details><summary>Example</summary>
<p>

ExampleDetectEntrypoint demonstrates automatic entrypoint detection.

```go
package main

import (
	"fmt"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func main() {
	// Archive with main.py
	tarData, _ := client.TarFromMap(map[string]string{
		"main.py":   `print("main")`,
		"helper.py": `print("helper")`,
	})

	entrypoint, err := client.DetectEntrypoint(tarData)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Detected entrypoint: %s\n", entrypoint)
}
```

#### Output

```
Detected entrypoint: main.py
```

</p>
</details>

<a name="TarFromDirectory"></a>
## func TarFromDirectory

```go
func TarFromDirectory(dirPath string) ([]byte, error)
```

TarFromDirectory creates an uncompressed tar archive from a directory.

All files in the directory are added recursively with relative paths.

Example:

```
tarData, err := client.TarFromDirectory("./myproject")
```

<a name="TarFromFiles"></a>
## func TarFromFiles

```go
func TarFromFiles(files []string) ([]byte, error)
```

TarFromFiles creates an uncompressed tar archive from a list of file paths.

Each file is added to the archive with its base name \(not the full path\).

Example:

```
tarData, err := client.TarFromFiles([]string{
    "main.py",
    "utils.py",
    "config.json",
})
```

<a name="TarFromMap"></a>
## func TarFromMap

```go
func TarFromMap(files map[string]string) ([]byte, error)
```

TarFromMap creates a tar archive from a map of filename to content.

This is the most convenient way to create a tar archive for simple scripts.

Example:

```
tarData, err := client.TarFromMap(map[string]string{
    "main.py":   `print("Hello!")`,
    "helper.py": `def greet(): print("Hi!")`,
})
```

<details><summary>Example</summary>
<p>

ExampleTarFromMap demonstrates creating a tar archive from a map.

```go
package main

import (
	"fmt"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func main() {
	files := map[string]string{
		"main.py":   `print("Hello from main!")`,
		"helper.py": `def greet(): return "Hi!"`,
	}

	tarData, err := client.TarFromMap(files)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Created tar archive: %d bytes\n", len(tarData))
}
```

#### Output

```
Created tar archive: 2048 bytes
```

</p>
</details>

<a name="TarFromReader"></a>
## func TarFromReader

```go
func TarFromReader(r io.Reader, filename string) ([]byte, error)
```

TarFromReader creates a tar archive from an io.Reader \(e.g., stdin\).

The content is read entirely and stored in the archive under the given filename.

Example:

```
tarData, err := client.TarFromReader(os.Stdin, "main.py")
```

<a name="AsyncResponse"></a>
## type AsyncResponse

AsyncResponse is returned when submitting async execution.

```go
type AsyncResponse struct {
    ExecutionID string `json:"execution_id"`
}
```

<a name="Client"></a>
## type Client

Client is the Go client for the python\-executor service.

Create a new client with [New](<#New>) and use methods like [Client.ExecuteSync](<#Client.ExecuteSync>) and [Client.ExecuteAsync](<#Client.ExecuteAsync>) to execute Python code remotely.

```go
type Client struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(baseURL string, opts ...Option) *Client
```

New creates a new python\-executor client.

The baseURL should point to the python\-executor server, e.g., "http://pyexec.cluster:9999/" or "http://localhost:8080".

Options can be used to customize the client:

```
c := client.New("http://localhost:8080",
    client.WithTimeout(60 * time.Second),
)
```

<details><summary>Example</summary>
<p>

ExampleNew demonstrates creating a new client.

```go
package main

import (
	"fmt"
	"time"

	"github.com/geraldthewes/python-executor/pkg/client"
)

func main() {
	// Create a client with default settings
	c := client.New("http://pyexec.cluster:9999/")
	_ = c

	// Create a client with custom timeout
	c2 := client.New("http://localhost:8080",
		client.WithTimeout(60*time.Second),
	)
	_ = c2

	fmt.Println("Clients created")
}
```

#### Output

```
Clients created
```

</p>
</details>

<a name="Client.ExecuteAsync"></a>
### func \(\*Client\) ExecuteAsync

```go
func (c *Client) ExecuteAsync(ctx context.Context, tarData []byte, metadata *Metadata) (string, error)
```

ExecuteAsync submits Python code for asynchronous execution.

Returns an execution ID immediately. Use [Client.GetExecution](<#Client.GetExecution>) to check status or [Client.WaitForCompletion](<#Client.WaitForCompletion>) to wait for the result.

Example:

```
execID, err := c.ExecuteAsync(ctx, tarData, &client.Metadata{
    Entrypoint: "main.py",
})
if err != nil {
    return err
}

// Later, wait for completion
result, err := c.WaitForCompletion(ctx, execID, 2*time.Second)
```

<a name="Client.ExecuteSync"></a>
### func \(\*Client\) ExecuteSync

```go
func (c *Client) ExecuteSync(ctx context.Context, tarData []byte, metadata *Metadata) (*ExecutionResult, error)
```

ExecuteSync executes Python code and waits for the result.

This method blocks until execution completes. Use [Client.ExecuteAsync](<#Client.ExecuteAsync>) for long\-running scripts.

Example:

```
tarData, _ := client.TarFromMap(map[string]string{
    "main.py": `print("Hello!")`,
})

result, err := c.ExecuteSync(ctx, tarData, &client.Metadata{
    Entrypoint: "main.py",
})
if err != nil {
    return err
}

fmt.Printf("Exit code: %d\n", result.ExitCode)
fmt.Printf("Output: %s\n", result.Stdout)
```

<a name="Client.GetExecution"></a>
### func \(\*Client\) GetExecution

```go
func (c *Client) GetExecution(ctx context.Context, executionID string) (*ExecutionResult, error)
```

GetExecution retrieves the current status and result of an execution.

Returns the execution status which may be pending, running, completed, failed, or killed. Once completed, the result includes stdout, stderr, and exit code.

<a name="Client.KillExecution"></a>
### func \(\*Client\) KillExecution

```go
func (c *Client) KillExecution(ctx context.Context, executionID string) error
```

KillExecution terminates a running execution.

The Docker container running the Python code will be forcefully stopped.

<a name="Client.WaitForCompletion"></a>
### func \(\*Client\) WaitForCompletion

```go
func (c *Client) WaitForCompletion(ctx context.Context, executionID string, pollInterval time.Duration) (*ExecutionResult, error)
```

WaitForCompletion polls the server until the execution completes.

The method polls at the specified interval until the execution reaches a terminal state \(completed, failed, or killed\).

Example:

```
execID, _ := c.ExecuteAsync(ctx, tarData, metadata)

// Poll every 2 seconds
result, err := c.WaitForCompletion(ctx, execID, 2*time.Second)
if err != nil {
    return err
}

fmt.Println(result.Stdout)
```

<a name="CodeFile"></a>
## type CodeFile

CodeFile represents a single file with its content

```go
type CodeFile struct {
    Name    string `json:"name"`    // filename (e.g., "main.py")
    Content string `json:"content"` // file content
}
```

<a name="ExecutionConfig"></a>
## type ExecutionConfig

ExecutionConfig holds resource limits and execution settings.

Example:

```
config := &client.ExecutionConfig{
    TimeoutSeconds:  60,
    NetworkDisabled: false,
    MemoryMB:        2048,
}
```

```go
type ExecutionConfig struct {
    // TimeoutSeconds is the maximum execution time (default: 300).
    TimeoutSeconds int `json:"timeout_seconds,omitempty"`
    // NetworkDisabled disables network access if true (default: true).
    NetworkDisabled bool `json:"network_disabled,omitempty"`
    // MemoryMB is the memory limit in megabytes (default: 1024).
    MemoryMB int `json:"memory_mb,omitempty"`
    // DiskMB is the disk space limit in megabytes (default: 2048).
    DiskMB int `json:"disk_mb,omitempty"`
    // CPUShares is the CPU shares (relative weight, default: 1024).
    CPUShares int `json:"cpu_shares,omitempty"`
}
```

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult contains the output and status of an execution.

```go
type ExecutionResult struct {
    // ExecutionID is the unique identifier for this execution.
    ExecutionID string `json:"execution_id"`
    // Status is the current execution state.
    Status ExecutionStatus `json:"status"`
    // Stdout is the standard output from the Python script.
    Stdout string `json:"stdout,omitempty"`
    // Stderr is the standard error from the Python script.
    Stderr string `json:"stderr,omitempty"`
    // ExitCode is the process exit code (0 = success).
    ExitCode int `json:"exit_code,omitempty"`
    // Error is an error message if the execution failed internally.
    Error string `json:"error,omitempty"`
    // ErrorType is the Python exception type (e.g., "SyntaxError", "NameError").
    ErrorType string `json:"error_type,omitempty"`
    // ErrorLine is the line number where the error occurred.
    ErrorLine int `json:"error_line,omitempty"`
    // StartedAt is when execution started (UTC).
    StartedAt *time.Time `json:"started_at,omitempty"`
    // FinishedAt is when execution finished (UTC).
    FinishedAt *time.Time `json:"finished_at,omitempty"`
    // DurationMs is the total execution time in milliseconds.
    DurationMs int64 `json:"duration_ms,omitempty"`
}
```

<a name="ExecutionStatus"></a>
## type ExecutionStatus

ExecutionStatus represents the status of a code execution.

```go
type ExecutionStatus string
```

<a name="StatusPending"></a>Execution status constants.

```go
const (
    // StatusPending indicates the execution is queued but not yet started.
    StatusPending ExecutionStatus = "pending"
    // StatusRunning indicates the execution is currently in progress.
    StatusRunning ExecutionStatus = "running"
    // StatusCompleted indicates the execution finished (check ExitCode for success).
    StatusCompleted ExecutionStatus = "completed"
    // StatusFailed indicates the execution failed due to an internal error.
    StatusFailed ExecutionStatus = "failed"
    // StatusKilled indicates the execution was terminated by the user.
    StatusKilled ExecutionStatus = "killed"
)
```

<a name="KillResponse"></a>
## type KillResponse

KillResponse is returned when killing an execution.

```go
type KillResponse struct {
    Status string `json:"status"`
}
```

<a name="Metadata"></a>
## type Metadata

Metadata contains execution parameters sent to the server.

At minimum, Entrypoint must be specified. All other fields are optional.

Example:

```
metadata := &client.Metadata{
    Entrypoint:      "main.py",
    RequirementsTxt: "requests\nnumpy",
    Config: &client.ExecutionConfig{
        NetworkDisabled: false,  // Allow network for pip
    },
}
```

```go
type Metadata struct {
    // Entrypoint is the Python file to execute (required).
    Entrypoint string `json:"entrypoint"`
    // DockerImage is the Docker image to use (default: python:3.11-slim).
    DockerImage string `json:"docker_image,omitempty"`
    // RequirementsTxt is the contents of requirements.txt for pip install.
    RequirementsTxt string `json:"requirements_txt,omitempty"`
    // PreCommands are shell commands to run before Python execution.
    PreCommands []string `json:"pre_commands,omitempty"`
    // Stdin is data to provide on standard input.
    Stdin string `json:"stdin,omitempty"`
    // Config contains resource limits and settings.
    Config *ExecutionConfig `json:"config,omitempty"`
    // EnvVars are environment variables in "KEY=value" format.
    EnvVars []string `json:"env_vars,omitempty"`
    // ScriptArgs are arguments passed to the Python script (sys.argv).
    ScriptArgs []string `json:"script_args,omitempty"`
}
```

<a name="Option"></a>
## type Option

Option is a functional option for configuring the [Client](<#Client>).

```go
type Option func(*Client)
```

<a name="WithHTTPClient"></a>
### func WithHTTPClient

```go
func WithHTTPClient(httpClient *http.Client) Option
```

WithHTTPClient sets a custom HTTP client.

Use this to configure custom transport settings, proxies, or TLS configuration.

Example:

```
transport := &http.Transport{
    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
}
httpClient := &http.Client{Transport: transport}
c := client.New(url, client.WithHTTPClient(httpClient))
```

<a name="WithTimeout"></a>
### func WithTimeout

```go
func WithTimeout(timeout time.Duration) Option
```

WithTimeout sets the HTTP client timeout.

The default timeout is 5 minutes.

Example:

```
c := client.New(url, client.WithTimeout(60*time.Second))
```

<a name="SimpleExecRequest"></a>
## type SimpleExecRequest

SimpleExecRequest is the JSON\-only execution request format Compatible with Replit/Piston\-style APIs for simpler integrations

```go
type SimpleExecRequest struct {
    // Code is the source code to execute (for single-file execution)
    // If provided, creates a main.py with this content
    Code string `json:"code,omitempty"`

    // Files allows multiple files to be provided (Piston-compatible)
    // Takes precedence over Code if both are provided
    Files []CodeFile `json:"files,omitempty"`

    // Entrypoint is the file to execute (defaults to "main.py")
    Entrypoint string `json:"entrypoint,omitempty"`

    // Stdin is the standard input to provide to the script
    Stdin string `json:"stdin,omitempty"`

    // Config contains execution resource limits
    Config *ExecutionConfig `json:"config,omitempty"`

    // PythonVersion specifies the Python version to use (e.g., "3.10", "3.11", "3.12", "3.13")
    // If not specified, uses the server default (typically 3.12)
    PythonVersion string `json:"python_version,omitempty"`
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
